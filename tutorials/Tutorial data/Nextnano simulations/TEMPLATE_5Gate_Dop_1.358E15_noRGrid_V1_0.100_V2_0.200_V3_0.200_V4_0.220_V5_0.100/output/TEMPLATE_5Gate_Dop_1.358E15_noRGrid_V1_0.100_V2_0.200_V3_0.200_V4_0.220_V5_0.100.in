 # 1D sample for solving current-poisson

#---------USER OPTIONS---------------------------------------------------------

# If Schroedinger equation (quantum mechanics) should not be solved, choose $QM = 0.
# In other case choose $QM = 1.
$QM = 0              # 0 (classical calculation) or 1 (quantum mechanical calculation)

#If you want to add light p-doping to the substrate
$DOPING = 1 

#------------------------------------------------------------------------------

#----------VARIABLES-----------------------------------------------------------

#SEMICONDUCTOR MATERIALS
$Al_WORKFUN = 4.1 
$Si_AFFINITY = 4.05 
$SiO2_AFFINITY = 0.9 
$BARRIER = $Al_WORKFUN - $SiO2_AFFINITY 

$SI_FERMI_LEVEL = 0 #Bias voltage applied on the Si substrate (i.e. the Si fermi level)
$TEMPERATURE = 0.1 
$DOP_CONC = 1.358E15 

#APPLIED VOLTAGES
$V1 = 0.100 
$V2 = 0.200 
$V3 = 0.200 
$V4 = 0.220 
$V5 = 0.100 

#Z DIRECTION
$METAL_THICKNESS = 10.0 
$OXIDE_THICKNESS = 75         #Thickness of the oxide that should prevent accumulation
$OXIDE_GATE = 17.0            #Thickness of the oxide where the quantum dot will be formed
$Si_SUBS_THICKNESS = 3000.0     #Thickness of the Si chip
$Si_SUBS_THICKNESS_OFFSET1 = 250 #Thickness of Si chip to have a finer grid before getting close to the 2DEG
$Si_SUBS_THICKNESS_OFFSET2 = 1000 
$D_DEPTHEST = 1               #Distance below the interface where the 2DEG is assumed to be
$D_DEPTHEST_OVER = 10.0            #Distance from the SiO2-Si interface into the Si Substrate (z-direction) over which electron accumulation occurs (overestimate)
$GRID_Z1 = 0.2                #Default value : 0.2 
$GRID_Z2 = 5.0                #Default value : 1.0   
$GRID_Z3 = 25.0               #Default value : 5.0
$GRID_Z4 = 100.0 
$GRID_Z5 = 500.0 
$GRID_Z6 = 10.0 

#X DIRECTION
$G_WIDTHX = 40          #This is the size of the gate metal and must be equal to or larger than $DOT_SIZE
$G_EXTRASIZEX = 5          #This is used to extend the region for fine grid around the gate. It must be less than $X_OFFSET_LEFT/RIGHT
$D_WIDTHX = $G_WIDTHX   #Size of the hole-gate which defines the quantum dot
$GRID_X1 = 2.5                #Default value : 2.0
$GRID_X2 = 5.0                #Default value : 4.0
$GRID_X3 = 10.0 

#Y DIRECTION
$G_WIDTHY = 40            #This is the size of the gate metal and must be equal to or larger than $DOT_SIZE
$G_EXTRASIZEY = 0 
$D_WIDTHY = $G_WIDTHY   #Size of the hole-gate which defines the quantum dot
$GRID_Y1 = 1.0          #Default value : 2.0
$GRID_Y2 = 5.0          #Default value : 4.0
$GRID_Y3 = 10.0 

#OTHER GATE PARAMETERS       #Gates are labelled from as left (L) and right (R), etc.
$G_GAP = 30        #This is the separation between the L and R gates from edge-to-edge
$G_ARMWIDTH = 40         #Defines the width of the gate arm leadnig to the "via" gate

#GRID SETTINGS
$N_GATES = 4                #Total (integer) number of gates to be simulated on left/right
$X_OFFSETM = 0          #An extra length added to the left in the X axis (does not include the length covered by the gates on the left side)
$X_OFFSETP = $X_OFFSETM          #An extra length added to the rigth in the X axis (does not include the length covered by the gates on the right side)
$Y_OFFSETM = 50           #An extra length added to the left in the Y axis
$Y_OFFSETP = 80         #An extra length added to the left in the Y axis - (the gate arm is along this y-direction)

#------------------------------------------------------------------------------

#---------MATLAB VARIABLES-----------------------------------------------------

#MATLAB VARIABLES 

#------------------------------------------------------------------------------

#---------DERIVED PARAMETERS---------------------------------------------------

#OPTIONS
$NODOPING = 1 - $DOPING 

#GATE SEPARTION SETTINGS                 #The center offset should be applied along the x axis
$G_CENTER_OFFSET = $G_WIDTHX + $G_GAP 

#GRID SETTINGS
$G_SPAN = $G_WIDTHX*$N_GATES + ($G_GAP*($N_GATES-1)) 

#------------------------------------------------------------------------------

global{ 
   simulate3D{}
   
   temperature  = $TEMPERATURE
   substrate{ name = "Si" }
   crystal_zb{ x_hkl = [1, 0, 0] y_hkl = [0, 1, 0] }
}<>

grid{
   zgrid{
      line{ pos = -$Si_SUBS_THICKNESS spacing = $GRID_Z5}
      line{ pos = -$Si_SUBS_THICKNESS_OFFSET2 spacing = $GRID_Z4}
      line{ pos = -$Si_SUBS_THICKNESS_OFFSET1 spacing = $GRID_Z3} 
      line{ pos = -($D_DEPTHEST_OVER) spacing = $GRID_Z2}
      line{ pos = -(2*$D_DEPTHEST) spacing = $GRID_Z1}
      line{ pos = $D_DEPTHEST spacing = $GRID_Z1}
      line{ pos = $OXIDE_GATE/2 spacing = $GRID_Z2}
      line{ pos = ($OXIDE_GATE + $OXIDE_THICKNESS)/2 spacing = $GRID_Z2}
      line{ pos = $METAL_THICKNESS + $OXIDE_THICKNESS spacing = $GRID_Z6}
   }
   xgrid{
      #Gate 1 (This gate is to help fix the boundary condition issues of simulating a chain of quantum dots)
      line{ pos  = -($G_WIDTHX/2 + $G_GAP) - 2*$G_CENTER_OFFSET spacing = $GRID_X3}
      line{ pos  = ($G_WIDTHX/2 + $G_EXTRASIZEX) - 2*$G_CENTER_OFFSET  spacing = $GRID_X2}
      line{ pos  = ($G_WIDTHX/2 + $G_GAP/2) - 2*$G_CENTER_OFFSET  spacing = $GRID_X2}      
      #Gate 2
      line{ pos  = -($G_WIDTHX/2 + $G_GAP/2) - $G_CENTER_OFFSET spacing = $GRID_X2}
      line{ pos  = -($G_WIDTHX/2 + $G_EXTRASIZEX) - $G_CENTER_OFFSET  spacing = $GRID_X1}
      line{ pos  = ($G_WIDTHX/2 + $G_EXTRASIZEX) - $G_CENTER_OFFSET  spacing = $GRID_X1}
      line{ pos  = ($G_WIDTHX/2 + $G_GAP/2) - $G_CENTER_OFFSET  spacing = $GRID_X2}
      #Gate 3
      line{ pos  = -($G_WIDTHX/2 + $G_GAP/2) spacing = $GRID_X2}
      line{ pos  = -($G_WIDTHX/2 + $G_EXTRASIZEX) spacing = $GRID_X1}
      line{ pos  = ($G_WIDTHX/2 + $G_EXTRASIZEX) spacing = $GRID_X1}
      line{ pos  = ($G_WIDTHX/2 + $G_GAP/2) spacing = $GRID_X2}
      #Gate 4
      line{ pos  = -($G_WIDTHX/2 + $G_GAP/2) + $G_CENTER_OFFSET spacing = $GRID_X2}
      line{ pos  = -($G_WIDTHX/2 + $G_EXTRASIZEX) + $G_CENTER_OFFSET  spacing = $GRID_X1}
      line{ pos  = ($G_WIDTHX/2 + $G_EXTRASIZEX) + $G_CENTER_OFFSET  spacing = $GRID_X1}
      line{ pos  = ($G_WIDTHX/2 + $G_GAP/2) + $G_CENTER_OFFSET  spacing = $GRID_X2}
      #Gate 4 (This gate is to help fix the boundary condition issues of simulating a chain of quantum dots)
      line{ pos  = -($G_WIDTHX/2 + $G_GAP/2) + 2*$G_CENTER_OFFSET spacing = $GRID_X2}
      line{ pos  = -($G_WIDTHX/2 + $G_EXTRASIZEX) + 2*$G_CENTER_OFFSET  spacing = $GRID_X2}
      line{ pos  = ($G_WIDTHX/2 + $G_GAP) + 2*$G_CENTER_OFFSET  spacing = $GRID_X3}
   }
   ygrid{
      line{ pos = -($Y_OFFSETM + $G_WIDTHY/2) spacing = $GRID_Y3}
      line{ pos = -($G_WIDTHY/2 + $G_EXTRASIZEY) spacing = $GRID_Y2}
      line{ pos = 0 spacing = $GRID_Y1}
      line{ pos = ($G_WIDTHY/2 + $G_EXTRASIZEY) spacing = $GRID_Y2}
      line{ pos = ($G_WIDTHY/2 + $Y_OFFSETP) spacing = $GRID_Y3}
   }

   periodic{                          # (optional)
      x = no                         # periodic along x direction (default is no)
      #y = yes/no                      # periodic along y direction (default is no) (2D or 3D only)
      #z = yes/no                      # periodic along z direction (default is no) (3D only)
   }
}<>

structure{
   #output_material_index{}
   #output_contact_index{}
   #output_impurities{}
   
   #Default Material       #There is an issue whenever I use Air: The result from the potential does not seem physical
   region{
      everywhere{}
      binary{ name = "SiO2" }
   }   

#----Gate1-----------------------------------------------------------------

   # Top Gate ARM OVER DOT
   region{
      cuboid{ 
         x = [-$G_WIDTHX/2 - 2*$G_CENTER_OFFSET, $G_WIDTHX/2 - 2*$G_CENTER_OFFSET]
         y = [-$G_WIDTHY/2, $G_WIDTHY/2]
         z = [$OXIDE_THICKNESS, $OXIDE_THICKNESS + $METAL_THICKNESS] 
      }
      contact{ name = "GateContact_1" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 

   # Top Gate ARM CONNECTING TO DOT
   region{
      cuboid{ 
         x = [-$G_ARMWIDTH/2 - 2*$G_CENTER_OFFSET, $G_ARMWIDTH/2 - 2*$G_CENTER_OFFSET]
         y = [$G_WIDTHY/2, $G_WIDTHY/2 + $Y_OFFSETP]
         z = [$OXIDE_THICKNESS, $OXIDE_THICKNESS + $METAL_THICKNESS] 
      }
      contact{ name = "GateContact_1" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 

   # Via-hole gate
   region{
      cuboid{ 
         x = [-$D_WIDTHX/2 - 2*$G_CENTER_OFFSET, $D_WIDTHX/2 - 2*$G_CENTER_OFFSET]
         y = [-$D_WIDTHY/2, $D_WIDTHY/2]
         z = [$OXIDE_GATE, $OXIDE_THICKNESS] 
      }
      contact{ name = "GateContact_1" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 

#----Gate2-----------------------------------------------------------------

   # Top Gate ARM OVER DOT
   region{
      cuboid{ 
         x = [-$G_WIDTHX/2 - $G_CENTER_OFFSET, $G_WIDTHX/2 - $G_CENTER_OFFSET]
         y = [-$G_WIDTHY/2, $G_WIDTHY/2]
         z = [$OXIDE_THICKNESS, $OXIDE_THICKNESS + $METAL_THICKNESS] 
      }
      contact{ name = "GateContact_2" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 

   # Top Gate ARM CONNECTING TO DOT
   region{
      cuboid{ 
         x = [-$G_ARMWIDTH/2 - $G_CENTER_OFFSET, $G_ARMWIDTH/2 - $G_CENTER_OFFSET]
         y = [$G_WIDTHY/2, $G_WIDTHY/2 + $Y_OFFSETP]
         z = [$OXIDE_THICKNESS, $OXIDE_THICKNESS + $METAL_THICKNESS] 
      }
      contact{ name = "GateContact_2" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 

   # Via-hole gate
   region{
      cuboid{ 
         x = [-$D_WIDTHX/2 - $G_CENTER_OFFSET, $D_WIDTHX/2 - $G_CENTER_OFFSET]
         y = [-$D_WIDTHY/2, $D_WIDTHY/2]
         z = [$OXIDE_GATE, $OXIDE_THICKNESS] 
      }
      contact{ name = "GateContact_2" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 

#----Gate3-----------------------------------------------------------------

   # Top Gate ARM OVER DOT
   region{
      cuboid{ 
         x = [-$G_WIDTHX/2, $G_WIDTHX/2]
         y = [-$G_WIDTHY/2, $G_WIDTHY/2]
         z = [$OXIDE_THICKNESS, $OXIDE_THICKNESS + $METAL_THICKNESS] 
      }
      contact{ name = "GateContact_3" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 

   # Top Gate ARM CONNECTING TO DOT
   region{
      cuboid{ 
         x = [-$G_ARMWIDTH/2, $G_ARMWIDTH/2]
         y = [$G_WIDTHY/2, $G_WIDTHY/2 + $Y_OFFSETP]
         z = [$OXIDE_THICKNESS, $OXIDE_THICKNESS + $METAL_THICKNESS] 
      }
      contact{ name = "GateContact_3" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 

   # Via-hole gate
   region{
      cuboid{ 
         x = [-$D_WIDTHX/2, $D_WIDTHX/2]
         y = [-$D_WIDTHY/2, $D_WIDTHY/2]
         z = [$OXIDE_GATE, $OXIDE_THICKNESS] 
      }
      contact{ name = "GateContact_3" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 
   
#----Gate4-----------------------------------------------------------------

   # Top Gate ARM OVER DOT
   region{
      cuboid{ 
         x = [-$G_WIDTHX/2 + $G_CENTER_OFFSET, $G_WIDTHX/2 + $G_CENTER_OFFSET]
         y = [-$G_WIDTHY/2, $G_WIDTHY/2]
         z = [$OXIDE_THICKNESS, $OXIDE_THICKNESS + $METAL_THICKNESS] 
      }
      contact{ name = "GateContact_4" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 

   # Top Gate ARM CONNECTING TO DOT
   region{
      cuboid{ 
         x = [-$G_ARMWIDTH/2 + $G_CENTER_OFFSET, $G_ARMWIDTH/2 + $G_CENTER_OFFSET]
         y = [$G_WIDTHY/2, $G_WIDTHY/2 + $Y_OFFSETP]
         z = [$OXIDE_THICKNESS, $OXIDE_THICKNESS + $METAL_THICKNESS] 
      }
      contact{ name = "GateContact_4" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 

   # Via-hole gate
   region{
      cuboid{ 
         x = [-$D_WIDTHX/2 + $G_CENTER_OFFSET, $D_WIDTHX/2 + $G_CENTER_OFFSET]
         y = [-$D_WIDTHY/2, $D_WIDTHY/2]
         z = [$OXIDE_GATE, $OXIDE_THICKNESS]
      }
      contact{ name = "GateContact_4" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 

#----Gate5-----------------------------------------------------------------

   # Top Gate ARM OVER DOT
   region{
      cuboid{ 
         x = [-$G_WIDTHX/2 + 2*$G_CENTER_OFFSET, $G_WIDTHX/2 + 2*$G_CENTER_OFFSET]
         y = [-$G_WIDTHY/2, $G_WIDTHY/2]
         z = [$OXIDE_THICKNESS, $OXIDE_THICKNESS + $METAL_THICKNESS] 
      }
      contact{ name = "GateContact_5" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 

   # Top Gate ARM CONNECTING TO DOT
   region{
      cuboid{ 
         x = [-$G_ARMWIDTH/2 + 2*$G_CENTER_OFFSET, $G_ARMWIDTH/2 + 2*$G_CENTER_OFFSET]
         y = [$G_WIDTHY/2, $G_WIDTHY/2 + $Y_OFFSETP]
         z = [$OXIDE_THICKNESS, $OXIDE_THICKNESS + $METAL_THICKNESS] 
      }
      contact{ name = "GateContact_5" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 

   # Via-hole gate
   region{
      cuboid{ 
         x = [-$D_WIDTHX/2 + 2*$G_CENTER_OFFSET, $D_WIDTHX/2 + 2*$G_CENTER_OFFSET]
         y = [-$D_WIDTHY/2, $D_WIDTHY/2]
         z = [$OXIDE_GATE, $OXIDE_THICKNESS]
      }
      contact{ name = "GateContact_5" }
      binary{
         name = "SiO2" # must be defined as SiO2 because it is next to a SiO2 layer (limitation of nextnano++)
      }
   } 

#----Si_Substrate--------------------------------------------------------------

   # "Si" substrate
   region{
      cuboid{
         x = [-($X_OFFSETM + $G_SPAN/2), ($X_OFFSETP + $G_SPAN/2)]           
         y = [-($Y_OFFSETM + $G_WIDTHY/2), ($Y_OFFSETP + $G_WIDTHY/2)]
         z = [-$Si_SUBS_THICKNESS, 0] 
      }
      contact { name = "SiContact" }
      binary{ name = "Si" }
      doping{
         #if $DOPING constant{
         #if $DOPING    name = "Boron"
         #if $DOPING    conc = $DOP_CONC #cm^-3
         #if $DOPING }
         #if $NODOPING constant{
         #if $NODOPING    name = "Boron"
         #if $NODOPING    conc = 0 #cm^-3
         #if $NODOPING }
      }
   }
}<>

impurities{
   donor{    
      name = "Phosporous"   
      energy = 0.044  # eV
      degeneracy = 2 }
   acceptor{ 
      name = "Boron"   
      energy = 0.045 # eV 
      degeneracy = 4 }
}<>

contacts{

#----Gate1-----------------------------------------------------------------
   schottky{
      name = GateContact_1
      bias = $V1
      barrier = $BARRIER
   }

#----Gate2-----------------------------------------------------------------
   schottky{
      name = GateContact_2
      bias = $V2
      barrier = $BARRIER
   }

#----Gate3-----------------------------------------------------------------
   schottky{
      name = GateContact_3
      bias = $V3
      barrier = $BARRIER
   }

#----Gate4-----------------------------------------------------------------
   schottky{
      name = GateContact_4
      bias = $V4
      barrier = $BARRIER
   }

#----Gate5-----------------------------------------------------------------
   schottky{
      name = GateContact_5
      bias = $V5
      barrier = $BARRIER
   }

#----Si_Substrate--------------------------------------------------------------

   fermi{ 
      name = "SiContact"
      bias = $SI_FERMI_LEVEL # apply voltage to poisson-cluster (required for Dirichlet)
   }
}<>

classical{
   #Gamma{}
   #X{}
   Delta{}
   HH{}
   LH{}
   SO{}

#   output_bandedges{}
#   output_carrier_densities{}
   #output_ionized_dopant_densities{}
   #output_intrinsic_density{}
}<>


poisson{
   output_potential{}
   #output_electric_field{}

   newton_solver{                      # parameters for solver of nonlinear poisson equation
      iterations   = 150               # number of iterations for Newton solver (default is: 30)
      search_steps = 50                # number of line search steps in Newton solver (default is: 20)
      #residual     = 1e-4              # residual for Newton solver (default is: 1e3/cm2 (1D), 1e1/cm (2D), 1e-4 (3D))
                                       # residual occupation changes
   }
}<>


currents{
   #mobility_model = minimos

   #recombination_model{
   #   SRH = no
   #   Auger = no
   #}

   #minimum_density = 1e10  # effects minimal current and convergence speed
   #linear_solver{
   #   abs_accuracy = 1e-12 # should be at least one order of magnitude smaller than residual in solve_current_poisson{} (default: 1e-6)
   #}

   #output_fermi_levels{}
   #output_currents{}
   #output_mobilities{}
   #output_recombination{}
}<>

quantum {
   region{
      name = "quantum_region"       # [Richter]    wavefunction does not penetrate  into SiO2 barrier (infinite barrier)
      x = [-($X_OFFSETM + $G_SPAN), ($X_OFFSETP + $G_SPAN)]           
      y = [-($Y_OFFSETM + $G_WIDTHY/2), ($Y_OFFSETP + $G_WIDTHY/2)]
      z = [-$D_DEPTHEST, 0] 

      boundary{
         x = dirichlet
         y = dirichlet
         z = dirichlet
      }
      
      #Gamma{
      #   num_ev = 40
      #}
      #X{
      #   num_ev = 40
      #}
      Delta{
         num_ev = 5
      }     
      #HH{
      #   num_ev = 40
      #}
      #LH{
      #   num_ev = 40
      #}
      #SO{
      #   num_ev = 40
      #}
      
      output_wavefunctions{
         max_num = 9999
         all_k_points = yes
         amplitudes = no
         probabilities = yes
      }
   }
}<>

output{
   directory = "output"
   
   format3D = AvsAscii

#   section1D{                                # ouput a 1D section of the simulation area (1D slice)
#      name = "line_alongX_Z_-0p75nm"           # name of section enters file name
#      z = -0.75
#      y = 0
#   }
#   section1D{                                # ouput a 1D section of the simulation area (1D slice)
#      name = "line_alongY_Z_-0p75nm"           # name of section enters file name
#      z = -0.75
#      x = 0
#   }
#   section1D{
#      name = "line_alongZ_XY_0nm"
#      x = 0
#      y = 0
#   }
}<>

run{
   #solve_current_poisson{
   #   residual = 1e-11     # small value for very precise current calculation (default: 1e-5)
   #   iterations = 1000    # precise current calculation possibly requires many iterations (default: 30)
   #   alpha_fermi = $ALPHA
   #}

   solve_poisson{}
   #if $QM solve_quantum{}
   #if $QM outer_iteration{} # (solve Schroedinger, Poisson (and current) self-consistently)

}<>
